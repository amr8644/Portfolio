
  std::string method = request.request_check_method(client->buffer);
  auto path = request.request_parse_url(client->buffer);
  std::cout << method << std::endl;
  // std::cout << path[0] << std::endl;
  if (routes.size() == 0) {
    std::cout << "No routes"
              << "\n";
    return -1;
  };
  for (auto x : routes) {
    std::cout << x.first << std::endl;
  }

  if (routes[path[0]] == "") {
    std::string ss =
        response.response_handle_header(NOT_FOUND, "text/plain", "Not Found");

    response.response_send(client->client_fd, ss);
    close(client->client_fd);
  } else {

    std::string body = response.response_read_file(path[0]);
    std::string ss = response.response_handle_header(OK, "text/html", body);

    response.response_send(client->client_fd, ss);
  };





    if (method == "POST") {
      std::string status_http_created = "HTTP/1.1 201 Created\r\n\r\n";
      write_file(res[1], nnf);
      send(client_fd, status_http_created.c_str(), status_http_created.size(),
           0);
      close(client_fd);
      continue;
    }

    if (res.size() < 2) {
      std::string OK = "HTTP/1.1 200 OK\r\nContent-Type: "
                       "text/plain\r\n\r\n";
      send(client_fd, OK.c_str(), OK.size(), 0);
      close(client_fd);
      continue;
    }

    if (res[0].find("files") != std::string::npos) {
      if (!check_file(res[1])) {
        send(client_fd, status_http_error.c_str(), status_http_error.size(), 0);
        close(client_fd);
        continue;
      } else {
        std::cout << res[1];
        std::string ff = read_file(res[1]);
        std::string siz = std::to_string(ff.size());
        status_http_OK += siz;
        status_http_OK += "\r\n\r\n";
        status_http_OK += ff;
        send(client_fd, status_http_OK.c_str(), status_http_OK.size(), 0);
        close(client_fd);
        continue;
      };
    }

    if (check_word(str, "User-Agent")) {
      auto res = parse_headers(str);
      std::string OK =
          "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: ";
      std::string siz = std::to_string(res.size() - 1);
      OK += siz;
      OK += "\r\n\r\n";
      OK += res;
      send(client_fd, OK.c_str(), OK.size(), 0);
      close(client_fd);
      continue;
    } else {
      if (check_word(str, "/echo")) {
        auto res = parse_url(str);
        std::string OK =
            "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: ";
        std::string siz = std::to_string(res[1].size());
        OK += siz;
        OK += "\r\n\r\n";
        OK += res[1];
        send(client_fd, OK.c_str(), OK.size(), 0);

        close(client_fd);
        continue;
      } else {
        send(client_fd, status_http_error.c_str(), status_http_error.size(), 0);
        close(client_fd);
        continue;
      };
    }
    close(client_fd);
  }
  close(server_fd);

  return 0;
}

std::string check_method(std::string request) {

  std::string method = "";

  for (size_t i = 0; i < request.size(); i++) {
    if (request[i] == ' ') {
      continue;
    }
    if (request[i] != '/') {
      method += request[i];
    } else {
      break;
    }
  }
  return method;
};

bool write_file(std::string filename, std::string content) {

  std::string dir = "/tmp/data/codecrafters.io/http-server-tester/";
  dir += filename;
  std::ofstream fp;

  fp.open(dir, std::ios_base::app);
  if (!fp.is_open()) {
    return false;
  }
  fp << content;
  fp.close();
  return true;
};
bool check_file(std::string filename) {

  std::string dir = "/tmp/data/codecrafters.io/http-server-tester/";
  dir += filename;
  std::ifstream nfp;
  nfp.open(dir);
  if (!nfp.is_open()) {
    return false;
  }
  return true;
};

std::string read_file(std::string filename) {

  std::string dir = "/tmp/data/codecrafters.io/http-server-tester/";
  std::string dirs = "/home/mertens/Desktop/Projects/cc/tmp/files/";
  dir += filename;
  std::ifstream nfp;
  std::string str;

  nfp.open(dir);
  std::ostringstream ss;
  ss << nfp.rdbuf();
  std::string fileContent = ss.str();

  return fileContent;
}

std::vector<std::string> parse_url(std::string response) {
  std::vector<std::string> r;
  for (int i = 0; i < response.size(); ++i) {

    if (response[i] == '\r')
      break;

    if (response[i] == '/') {
      if (response[i + 1] == ' ') {
        break;
      }
      int p = i + 1;
      std::string str = {};
      while (response[p] != '\r' && response[p] != ' ') {
        str.push_back(response[p]);
        p++;
      }
      r.push_back(str);
    }
  }

  return r;
};

bool check_word(std::string request, std::string word) {
  size_t spos = request.find(word);
  if (spos == std::string::npos)
    return false;

  return true;
};

std::string parse_request_body(std::string request) {

  std::string body = "";
  size_t spos = request.find("\r\n\r\n");

  if (spos == std::string::npos) {
    std::cerr << "[!]Not Found" << std::endl;
  }

  for (size_t i = spos; i < request.size(); i++) {
    if (request[i] == '\n' || request[i] == '\r') {
      continue;
    }
    body += request[i];
  }
  return body;
};

std::string parse_headers(std::string request) {

  std::string user_agent = "";
  size_t spos = request.find("User-Agent");

  if (spos == std::string::npos) {
    std::cerr << "[!]Not Found" << std::endl;
  }

  for (size_t i = spos + 12; i < request.size(); i++) {
    if (request[i] != '\n') {
      user_agent += request[i];
    } else {
      break;
    }
  }

  return user_agent;
};
